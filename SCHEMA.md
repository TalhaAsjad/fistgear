# Fist Gear - Database Schema

## Overview

Fist Gear uses **PostgreSQL** as its database, **Drizzle ORM** for schema definition and queries, and **better-auth** for authentication. The schema has two layers: the four tables better-auth requires (user, session, account, verification), plus three tables for the ecommerce features (product, product_variant, cart_item).

---

## Stack

| Layer        | Technology  | Role                                      |
|--------------|-------------|-------------------------------------------|
| Database     | PostgreSQL  | Stores all app data                       |
| ORM          | Drizzle ORM | Schema definition, migrations, queries    |
| Auth Library | better-auth | Signup, login, sessions, password hashing |

---

## Table Map

```
user               ← core user record (role: customer | admin)
 ├── session        ← active login sessions
 ├── account        ← login methods (email/password, OAuth)
 └── cart_item      ← customer's shopping cart
        └── product_variant  ← the specific variant in the cart
               └── product   ← the base product

product            ← base product info (admin-managed)
 └── product_variant ← purchasable size/color combinations

verification       ← email verification tokens + admin invite tokens
```

---

## Tables

### 1. `user`

Core user record. Every person who signs up gets one row here. The `role` column determines which part of the app they can access.

| Column           | Type      | Constraints                      | Description                              |
|------------------|-----------|----------------------------------|------------------------------------------|
| `id`             | text      | PK                               | Unique user ID (generated by better-auth)|
| `name`           | text      | NOT NULL                         | Full name — "First Last" from signup     |
| `email`          | text      | NOT NULL, UNIQUE                 | Login email                              |
| `email_verified` | boolean   | NOT NULL, default `false`        | Becomes `true` after email confirmation  |
| `image`          | text      | nullable                         | Profile image URL                        |
| **`role`**       | **text**  | **NOT NULL, default `customer`** | **`"customer"` or `"admin"`**           |
| `created_at`     | timestamp | NOT NULL, default `now()`        | When the account was created             |
| `updated_at`     | timestamp | NOT NULL, default `now()`        | Last modification time                   |

**Notes:**
- `role` defaults to `"customer"` for every signup — no one can self-register as admin
- First admin is bootstrapped manually: `UPDATE "user" SET role = 'admin' WHERE email = '...'`
- Subsequent admins are created via the invite system (`role = "admin"` set programmatically)

---

### 2. `session`

Tracks active login sessions. Each time a user logs in, a session row is created. Deleting it logs them out.

| Column       | Type      | Constraints              | Description                      |
|--------------|-----------|--------------------------|----------------------------------|
| `id`         | text      | PK                       | Session identifier               |
| `user_id`    | text      | NOT NULL, FK → `user.id` | Which user owns this session     |
| `token`      | text      | NOT NULL, UNIQUE         | Random token stored as a cookie  |
| `expires_at` | timestamp | NOT NULL                 | When the session becomes invalid |
| `ip_address` | text      | nullable                 | IP of the device at login        |
| `user_agent` | text      | nullable                 | Browser/device info at login     |
| `created_at` | timestamp | NOT NULL, default `now()` | Session creation time           |
| `updated_at` | timestamp | NOT NULL, default `now()` | Last update time                |

**On delete:** If a user is deleted, all their sessions are cascade-deleted.

---

### 3. `account`

Links a user to their login method(s). A single user can have multiple account rows — one per login method (e.g., email/password and Google each get their own row, both pointing to the same `user`).

**Identity columns** — always present:

| Column      | Type | Constraints              | Description                                                                |
|-------------|------|--------------------------|----------------------------------------------------------------------------|
| `id`        | text | PK                       | Account record identifier                                                  |
| `user_id`   | text | NOT NULL, FK → `user.id` | The user this login method belongs to                                      |
| `provider_id` | text | NOT NULL               | Login type: `"credential"` (email/password), `"google"`, or `"apple"`    |
| `account_id`  | text | NOT NULL               | The user's ID on the provider's side. For `"credential"`, equals `user.id` |

**Credential column** — only set when `provider_id = "credential"`:

| Column     | Type | Constraints | Description                                     |
|------------|------|-------------|-------------------------------------------------|
| `password` | text | nullable    | Bcrypt-hashed password. Null for OAuth logins.  |

**OAuth columns** — only set for Google/Apple logins. All null for email/password:

| Column                     | Type      | Constraints | Description                                                          |
|----------------------------|-----------|-------------|----------------------------------------------------------------------|
| `access_token`             | text      | nullable    | Short-lived token used to call Google/Apple APIs on the user's behalf |
| `refresh_token`            | text      | nullable    | Long-lived token used to get a new access token when it expires      |
| `access_token_expires_at`  | timestamp | nullable    | When the access token expires                                        |
| `refresh_token_expires_at` | timestamp | nullable    | When the refresh token expires                                       |
| `scope`                    | text      | nullable    | Permissions granted (e.g., `"email profile"`)                       |
| `id_token`                 | text      | nullable    | Signed JWT from Google/Apple proving the user's identity             |

**Timestamps:**

| Column       | Type      | Constraints               | Description            |
|--------------|-----------|---------------------------|------------------------|
| `created_at` | timestamp | NOT NULL, default `now()` | Record creation time   |
| `updated_at` | timestamp | NOT NULL, default `now()` | Last update time       |

**On delete:** If a user is deleted, all their account rows are cascade-deleted.

**For Fist Gear right now:** Every user has one account row with `provider_id = "credential"` and a hashed `password`. All OAuth columns are `null` — they're ready for when Google/Apple login is added.

---

### 4. `verification`

Dual-purpose table: email verification tokens AND admin invite tokens. Same structure, different use case and TTL.

| Column       | Type      | Constraints               | Description                                                           |
|--------------|-----------|---------------------------|-----------------------------------------------------------------------|
| `id`         | text      | PK                        | Record ID                                                             |
| `identifier` | text      | NOT NULL                  | The email address being verified or invited                           |
| `value`      | text      | NOT NULL                  | The token (UUID) sent in the email link                               |
| `expires_at` | timestamp | NOT NULL                  | Email verification: short TTL. Admin invite: 48 hours from creation.  |
| `created_at` | timestamp | NOT NULL, default `now()` | When the token was created                                            |
| `updated_at` | timestamp | NOT NULL, default `now()` | Last modification time                                                |

**Admin invite flow:**
1. Admin enters email → row inserted: `{ identifier: email, value: uuid-token, expires_at: now+48h }`
2. Invite email sent via Resend with link: `/auth/accept-invite?token=[value]`
3. Invitee clicks link → server checks token exists and `expires_at > now()`
4. Invitee fills admin signup form → `user` created with `role = "admin"` → token row deleted

---

### 5. `product`

Base product record. Created and managed entirely through the admin UI at `/admin/products`. One row per product (e.g., "V3 Apex Pro Gloves"). Prices and stock live on `product_variant`, not here.

| Column        | Type      | Constraints               | Description                                                          |
|---------------|-----------|---------------------------|----------------------------------------------------------------------|
| `id`          | text      | PK                        | Product ID (generated)                                               |
| `name`        | text      | NOT NULL                  | Product name shown on shop — e.g., "V3 Apex Pro Gloves"             |
| `description` | text      | nullable                  | Full description shown on the product detail view                    |
| `category`    | text      | NOT NULL                  | `"pro-series"`, `"sparring"`, or `"bag-work"` — used for filtering  |
| `brand`       | text      | nullable                  | e.g., "Fist Gear", "Rival", "Winning"                               |
| `image_url`   | text      | nullable                  | Main product image — URL from paste or Vercel Blob upload            |
| `is_active`   | boolean   | NOT NULL, default `true`  | `false` = hidden from shop. Products are never hard-deleted.         |
| `created_at`  | timestamp | NOT NULL, default `now()` | When the product was created                                         |
| `updated_at`  | timestamp | NOT NULL, default `now()` | Last modification time                                               |

**Notes:**
- Products are **never hard-deleted**. `is_active = false` hides them from `/shop`.
- A product with zero variants exists in the DB but nothing is purchasable — admin sees a warning.
- Customer shop query: `SELECT * FROM product WHERE is_active = true`

---

### 6. `product_variant`

Each row is one purchasable item — a specific size/color combination of a product. This is what the customer adds to their cart. A single product can have many variants.

| Column       | Type      | Constraints                          | Description                                                              |
|--------------|-----------|--------------------------------------|--------------------------------------------------------------------------|
| `id`         | text      | PK                                   | Variant ID (generated)                                                   |
| `product_id` | text      | NOT NULL, FK → `product.id` (CASCADE)| The parent product this variant belongs to                               |
| `size`       | text      | nullable                             | e.g., `"10oz"`, `"12oz"`, `"14oz"`, `"16oz"`                           |
| `color`      | text      | nullable                             | e.g., `"Black"`, `"Red"`, `"White"`                                     |
| `price`      | integer   | NOT NULL                             | **Stored in cents.** $79.99 is stored as `7999`. Display: `price / 100` |
| `stock`      | integer   | NOT NULL, default `0`                | Available units. `0` = "Out of Stock" shown on shop.                    |
| `weight`     | integer   | nullable                             | In grams. e.g., `340` → displayed as "340g"                            |
| `image_url`  | text      | nullable                             | Variant-specific image — overrides `product.image_url` if set           |
| `created_at` | timestamp | NOT NULL, default `now()`            | When the variant was created                                             |
| `updated_at` | timestamp | NOT NULL, default `now()`            | Last modification time                                                   |

**Notes:**
- `price` stored as **integer in cents** — avoids all floating-point rounding issues. Always display as `(price / 100).toFixed(2)`.
- `stock` is **not decremented on add-to-cart** — only decrements at checkout (future feature). Cart = intent, not commitment.
- `stock = 0` disables the "Add to Cart" button on the shop.

**Example — V3 Apex Pro Gloves variants:**

| id | product_id | size  | color | price | stock | weight |
|----|------------|-------|-------|-------|-------|--------|
| v1 | p1         | 12oz  | Black | 7999  | 15    | 340    |
| v2 | p1         | 12oz  | Red   | 7999  | 8     | 340    |
| v3 | p1         | 16oz  | Black | 8999  | 12    | 400    |
| v4 | p1         | 16oz  | Red   | 8999  | 0     | 400    |

---

### 7. `cart_item`

One row per unique (user + variant) combination. Represents what a customer has in their cart. DB-backed — persists across sign-outs and across devices.

| Column       | Type      | Constraints                                  | Description                                     |
|--------------|-----------|----------------------------------------------|-------------------------------------------------|
| `id`         | text      | PK                                           | Cart item ID                                    |
| `user_id`    | text      | NOT NULL, FK → `user.id` (CASCADE)           | The customer this cart item belongs to          |
| `variant_id` | text      | NOT NULL, FK → `product_variant.id` (CASCADE)| The specific variant (size/color) in the cart   |
| `quantity`   | integer   | NOT NULL, default `1`                        | How many units. Always >= 1.                    |
| `created_at` | timestamp | NOT NULL, default `now()`                    | When the item was first added                   |
| `updated_at` | timestamp | NOT NULL, default `now()`                    | Last modification time (e.g., quantity changes) |

**Unique constraint:** `UNIQUE(user_id, variant_id)`
- Enforced at the DB level — no duplicate rows even under concurrent requests
- Application uses upsert: `INSERT ... ON CONFLICT (user_id, variant_id) DO UPDATE SET quantity = quantity + 1`

**Cart load query:**
```sql
SELECT
  cart_item.id,
  cart_item.quantity,
  product_variant.size,
  product_variant.color,
  product_variant.price,
  product_variant.stock,
  product_variant.image_url  AS variant_image,
  product.name,
  product.image_url          AS product_image,
  product.is_active
FROM cart_item
JOIN product_variant ON cart_item.variant_id       = product_variant.id
JOIN product         ON product_variant.product_id = product.id
WHERE cart_item.user_id = $1
```

**Validation on every cart page load:**
- `product.is_active = false` → item shown as "No longer available", excluded from cart total
- `variant.stock = 0` → item shown as "Out of stock", quantity controls disabled
- `cart_item.quantity > variant.stock` → quantity auto-adjusted down, warning shown

---

## Relationships

```
user (1)
 ├── session (many)            user.id = session.user_id
 ├── account (many)            user.id = account.user_id
 └── cart_item (many)          user.id = cart_item.user_id

product (1)
 └── product_variant (many)    product.id = product_variant.product_id

product_variant (1)
 └── cart_item (many)          product_variant.id = cart_item.variant_id

verification (standalone)      used for email verification + admin invites
```

---

## Auth Flow

### Customer Sign Up
1. Submit: first name, last name, email, password
2. better-auth creates `user` row — `role = "customer"` (default)
3. better-auth creates `account` row — `provider_id = "credential"`, `password = hashed`
4. better-auth creates `session` row, sends token as cookie
5. Middleware reads `role = "customer"` → redirect to `/shop`

### Admin Sign In
1. Submit: email, password on the Admin Sign In tab
2. better-auth validates password in `account` table
3. Creates new `session` row, sends token as cookie
4. Middleware reads `role = "admin"` → redirect to `/admin`
5. If `role ≠ "admin"` → error: "This account does not have admin access"

### Session Check (every request)
1. Browser sends session cookie
2. Middleware reads session via better-auth
3. Valid and not expired → check role → route to correct area
4. Expired or missing → redirect to `/`

---

## Key Design Decisions

| Decision | Reasoning |
|----------|-----------|
| `role` on `user` table | Zero extra queries — middleware reads role from the same session lookup |
| Price in cents (integer) | No floating-point errors. $79.99 stored as `7999` |
| Variant model | Admin creates one product, adds many variants. Clean catalog — no separate product per size/color |
| `UNIQUE(user_id, variant_id)` on cart_item | DB-level guarantee against duplicates. Enables safe upsert |
| No hard deletes on product | Preserves cart integrity — deactivated items show as "unavailable" rather than disappearing |
| DB-backed cart | Persists across sessions and devices. Tamper-proof |
| Stock not decremented on add-to-cart | Cart = intent. Stock only decreases at checkout |
| `verification` reused for admin invites | Same structure (identifier, value, expires_at) — no extra table needed |

---

## Migrations

```bash
# Generate a migration after changing schema.ts
npx drizzle-kit generate

# Apply migration to Neon DB
npx drizzle-kit migrate
```

Migration files are stored in `/drizzle/`. Config in [drizzle.config.ts](drizzle.config.ts).

---

## File Reference

| File | Purpose |
|------|---------|
| [src/db/schema.ts](src/db/schema.ts) | All Drizzle table definitions |
| [src/db/index.ts](src/db/index.ts) | Database connection (pg Pool) |
| [drizzle.config.ts](drizzle.config.ts) | Drizzle Kit config (migrations) |
| `.env.local` | `DATABASE_URL` connection string |
